check_flx2015_version(datasetname, flx2015_version)
qc_flags <- get_qc_flags(datasetname, flx2015_version)
Sprd_MissingVal <- -9999 # missing value in spreadsheet
Nc_MissingVal   <- -9999 # missing value in created netcdf files
#Name of time stamp and QC variables
if(datasetname=="LaThuile"){
time_vars <- c("Year", "DoY", "Time", "DTIME")
qc_name <- "qc"
} else {
time_vars <- c("TIMESTAMP_START", "TIMESTAMP_END")
qc_name <- "_QC"
}
#Do some initial checks that arguments set correctly
InitialChecks(met_gapfill, era_file, missing, aggregate,
datasetname, flx2015_version)
################################
###--- Read variable data ---###
################################
#File contains desired variables (refer to Fluxnet2015 documentation for full variable descriptions;
#http://fluxnet.fluxdata.org/data/fluxnet2015-dataset/fullset-data-product/)
#Separate file available for La Thuile synthesis as variable names differ
#(see http://fluxnet.fluxdata.org/data/la-thuile-dataset/)
#Find variable file path (not using data() command directly because reads a CSV with a
#semicolon separator and this leads to incorrect table headers)
vars <- read.csv(var_file, header=TRUE,
colClasses=c("character", "character", "character",
"character", "character", "character",
"character", "numeric", "numeric",
"logical", "logical", "character"))
#Read site information (lon, lat, elevation)
site_info <- get_site_metadata(site_code)
#Log possible warnings and remove warnings from output var
site_log  <- log_warning(warn=site_info$warn, site_log)
site_info <- site_info$out
#Should site be excluded? If so, abort and print reason.
#This option is set in the site info file (inside data folder)
#Mainly excludes sites with mean annual ET excluding P, implying
#irrigation or other additional water source.
if(site_info$Exclude){
error <- paste("Site not processed. Reason:", site_info$Exclude_reason,
". This is set in site info file, change >Exclude< options",
"in the file to process site")
stop_and_log(error, site_log)
}
### Find model-specific parameters ###
model_params <- initialise_model(model, site_info)
# Read text file containing flux data
DataFromText <- ReadCSVFluxData(fileinname=infile, vars=vars,
datasetname=datasetname,
time_vars=time_vars, site_log,
fair_usage=fair_use,
fair_usage_vec=fair_use_vec,
site_code=site_code)
# Make sure whole number of days in dataset
CheckCSVTiming(DataFromText, site_log)
#Replace vars with those found in file
vars <- DataFromText$vars
#Check for missing values in QC flags when data available
#In FLUXNET2015 Nov 16 release, QC flags are missing in some
#cases even when data is available. This is because the flags
#apply to both LE_F_MDS and LE_CORR (and similarly H) but are
#only reported when LE_CORR is available
#(pers. comm. with D. Papale, Fluxnet)
#Set these time steps to 3 (poor gap-filling)
DataFromText <- FillQCvarMissing(datain=DataFromText, missingVal=Sprd_MissingVal,
gapfillVal=qc_flags$QC_gapfilled, qc_name=qc_name)
# Check if variables have gaps in the time series and determine what years to output:
gaps  <- CheckDataGaps(datain = DataFromText, missing_val = Sprd_MissingVal,
qc_flags=qc_flags, missing=missing, gapfill_all=gapfill_all,
gapfill_good=NA, gapfill_med=NA, gapfill_poor=NA, min_yrs=min_yrs,
qc_name=qc_name, showWarn=FALSE, site_log=site_log)
#Log possible warnings and remove warnings from output var
site_log <- log_warning(warn=gaps$warn, site_log)
gaps     <- gaps$out
## Check that gap check found whole years ##
IsWholeYrs(datain=DataFromText, gaps, site_log)
##############################################
###--- Gapfill meteorological variables ---###
##############################################
if(!is.na(met_gapfill)){
#Gapfill using statistical methods
if(met_gapfill == "statistical") {
gapfilled_met <- GapfillMet_statistical(datain=DataFromText, qc_name=qc_name,
qc_flags=qc_flags, copyfill=copyfill,
linfill=linfill, lwdown_method=lwdown_method,
elevation=site_info$SiteElevation,
gaps=gaps, site_log=site_log)
DataFromText <- gapfilled_met$data
site_log     <- gapfilled_met$site_log
# Gapfill using ERA-interim data provided as part of FLUXNET2015
} else if(met_gapfill == "ERAinterim") {
#Gapfill with ERAinterim
DataFromText <- GapfillMet_with_ERA(DataFromText, era_file,
qc_name, qc_flags)
#Cannot recognise method, stop
} else {
stop(paste("Cannot ascertain met_gapfill method. Choose one of",
"'ERAinterim' and 'statistical' or set to NA if not desired"))
}
}
####################################
###--- Gapfill flux variables ---###
####################################
#Gapfill flux variables using statistical methods
if(!is.na(flux_gapfill)){
gapfilled_flux <- GapfillFlux(DataFromText, qc_name, qc_flags,
regfill, linfill, copyfill,
gaps, site_log)
DataFromText <- gapfilled_flux$dataout
site_log     <- gapfilled_flux$site_log
}
############################################
### Aggregate data to a longer time step ###
############################################
if(!is.na(aggregate)){
# Aggregate to a coarser time step as set by argument aggregate
# QC flags are set to a fraction measured+good gapfilling
# (as per FLUXNET2015 convention for aggregated data)
aggregated_data <- aggregate_tsteps(datain=DataFromText, new_tstep=aggregate,
qc_flags=qc_flags, qc_name=qc_name)
#update QC flag info
DataFromText <- aggregated_data$data
qc_flags     <- aggregated_data$qc_flags
}
#################################################################
### Update info on data gaps after gapfilling and aggregating ###
#################################################################
#Update gaps after gapfilling and/or aggregating. Setting missing to 0 here to make sure
#missing met variables not passed through
#Setting gapfill_all to gapfill_all+missing so matches the level of missing and
#gap-filling originally passed to the function
if(!is.na(met_gapfill) | !is.na(flux_gapfill) | !is.na(aggregate)){
if(!is.na(met_gapfill) | !is.na(flux_gapfill)){
miss    <- 0
gap_all <- sum(gapfill_all, gapfill_good, gapfill_med,
gapfill_poor, missing, na.rm=TRUE)
} else{
miss    <- missing
gap_all <- sum(gapfill_all, gapfill_good, gapfill_med,
gapfill_poor, na.rm=TRUE)
}
gaps  <- CheckDataGaps(datain=DataFromText, missing_val=Sprd_MissingVal,
qc_flags=qc_flags, missing=miss, gapfill_all=gap_all,
gapfill_good=NA, gapfill_med=NA,
gapfill_poor=NA, min_yrs=min_yrs,
qc_name=qc_name, showWarn=FALSE,
aggregate=aggregate, site_log=site_log)
#Log possible warnings and remove warnings from output var
site_log <- log_warning(warn=gaps$warn, site_log)
gaps     <- gaps$out
}
### Save info on which evaluation variables have all values missing ###
#These are excluded when writing NetCDF file
#Find variables with all values missing
all_missing <- lapply(gaps$total_missing, function(x) names(which(x==100)))
exclude_eval <- rep(NA, length(all_missing))
if(any(sapply(all_missing, length) > 0) | !include_all_eval){
#Find variables to exclude
exclude_eval <- FindExcludeEval(datain=DataFromText, all_missing=all_missing,
gaps=gaps, include_all=include_all_eval,
qc_name=qc_name)
}
############################################################
### Calculate average annual precip if outputting precip ###
############################################################
# Written as an attribute to file. Calculated before converting
# data units, i.e. assumes rainfall units mm/timestep
if(any(DataFromText$attributes[,1]=="P")){
#Check that units in mm
if(DataFromText$units$original_units["P"] == "mm"){
av_precip <- calc_avPrecip(datain=DataFromText, gaps=gaps)
} else{
warn = paste("Cannot ascertain P units, expecting 'mm'.",
"Not outputting average precip as a netcdf attribute")
site_log <- warn_and_log(warn, site_log)
}
} else {
#Set to NA, repeat to match no. of output files
av_precip=rep(NA, length(unique(gaps$consec)))
}
###########################################
### Convert units and check data ranges ###
###########################################
# Convert data units from original Fluxnet units
# to desired units as set in variables.csv
ConvertedData <- ChangeUnits(DataFromText, site_log)
# Check that data are within acceptable ranges:
CheckDataRanges(ConvertedData, missingval=Nc_MissingVal, site_log)
#Replace original data with converted data
DataFromText <- ConvertedData
#Determine number of files to be written
no_files <- length(unique(gaps$consec))
####################################################
###--- Write output met and flux NetCDF files ---###
####################################################
#Gather argument info
arg_info <- list(infile=infile, datasetversion=datasetversion, datasetname=datasetname,
flx2015_version=flx2015_version, fair_use=fair_use,
met_gapfill=met_gapfill, flux_gapfill=flux_gapfill,
era_file=era_file, missing=missing, gapfill_all=gapfill_all,
gapfill_good=gapfill_good, gapfill_med=gapfill_med,
gapfill_poor=gapfill_poor, min_yrs=min_yrs,
linfill=linfill, copyfill=copyfill, regfill=regfill,
lwdown_method=lwdown_method, include_all_eval=include_all_eval,
aggregate=aggregate, model=model)
#Initialise variables to save output file names (used to write log and for plotting)
met_files  <- vector()
flux_files <- vector()
start_yr   <- vector()
end_yr     <- vector()
flux_ind   <- list()
#save to loops so no_files can be amended below
loops <- no_files
1800/60/60/24
1800/60/60
k=1
### First check that there are evalution variables to output ##
#If not, skip this file
#Find eval variable indices
flux_ind[[k]] <- FindFluxInd(datain=DataFromText,
exclude_eval=exclude_eval[[k]],
k, site_log)
#Log possible warnings and remove warnings from output var
site_log <- log_warning(warn=flux_ind[[k]]$warn, site_log)
flux_ind[[k]] <- flux_ind[[k]]$out
#If no eval vars for any time period, abort
if(k==no_files & all(sapply(flux_ind, length)==0)){
error <- paste("No evaluation variables to process for any output",
"time periods. Site not processed.")
stop_and_log(error, site_log)
#If no eval variables for this loop, skip to next
} else if(length(flux_ind[[k]]) == 0) {
no_files <- no_files-1
next
}
### Find start and end time ###
#Find start year, day and hour
nc_starttime <- findStartTime(start = strptime(DataFromText$time[gaps$tseries_start[k],1], "%Y%m%d%H%M"))
#Extract start and end years
start_yr[k] <- substring(DataFromText$time[gaps$tseries_start[k],1], 1, 4)
end_yr[k]   <- substring(DataFromText$time[gaps$tseries_end[k],1], 1, 4)
### Create output file names ###
#If only one year, only write start year, else write time period
if(start_yr[k]==end_yr[k]){
metfilename  <- paste(out_paths$nc, "/", site_code, "_", start_yr[k],
"_", datasetname, "_Met.nc", sep="")
fluxfilename <- paste(out_paths$nc, "/", site_code, "_", start_yr[k],
"_", datasetname, "_Flux.nc", sep="")
} else {
metfilename  <- paste(out_paths$nc, "/", site_code, "_", start_yr[k],
"-", end_yr[k], "_", datasetname, "_Met.nc", sep="")
fluxfilename <- paste(out_paths$nc, "/", site_code, "_", start_yr[k],
"-", end_yr[k], "_", datasetname, "_Flux.nc", sep="")
}
#Save file names
met_files[k]  <- metfilename
flux_files[k] <- fluxfilename
###--- Create netcdf met driving file ---###
#Find met variable indices
met_ind <- which(DataFromText$categories=="Met")
datain=DataFromText
paste("Aggregated from", (datain$original_timestepsize/60/60),
"hours to", datain$timestepsize/60/60, "hours")
!is.na(arg_info$met_gapfill)
arg_info$met_gapfill=="ERAinterim"
arg_info
names(arg_info)
paste("linfill: ", arg_info$linfill,", copyfill: ", arg_info$copyfill,
", lwdown_method: ", arg_info$lwdown_method, sep="")
write_model_params
arg_info
datain$gapfill_met
?ncvar_def
library(ncdf4)
?ncvar_def
source('~/Documents/FLUXNET2016_processing/scripts/R/FluxtowerSpreadsheetToNc.R')
source('~/Documents/FLUXNET2016_processing/scripts/R/FluxtowerSpreadsheetToNc.R')
#Write met file
CreateMetNetcdfFile(metfilename=metfilename,
datain=DataFromText,
site_code=site_code,
siteInfo=site_info,
datasetversion=datasetversion,
ind_start=gaps$tseries_start[k],
ind_end=gaps$tseries_end[k],
starttime=nc_starttime,
av_precip=av_precip[[k]],
total_missing=gaps$total_missing[[k]][met_ind],
total_gapfilled=gaps$total_gapfilled[[k]][met_ind],
qcInfo=qc_flags$qc_info,
arg_info=arg_info,
var_ind=met_ind,
modelInfo=model_params)
#Write met file
CreateMetNetcdfFile(metfilename=metfilename,
datain=DataFromText,
site_code=site_code,
siteInfo=site_info,
ind_start=gaps$tseries_start[k],
ind_end=gaps$tseries_end[k],
starttime=nc_starttime,
av_precip=av_precip[[k]],
total_missing=gaps$total_missing[[k]][met_ind],
total_gapfilled=gaps$total_gapfilled[[k]][met_ind],
qcInfo=qc_flags$qc_info,
arg_info=arg_info,
var_ind=met_ind,
modelInfo=model_params)
source('~/Documents/FLUXNET2016_processing/scripts/R/FluxtowerSpreadsheetToNc.R')
#Write met file
CreateMetNetcdfFile(metfilename=metfilename,
datain=DataFromText,
site_code=site_code,
siteInfo=site_info,
ind_start=gaps$tseries_start[k],
ind_end=gaps$tseries_end[k],
starttime=nc_starttime,
av_precip=av_precip[[k]],
total_missing=gaps$total_missing[[k]][met_ind],
total_gapfilled=gaps$total_gapfilled[[k]][met_ind],
qcInfo=qc_flags$qc_info,
arg_info=arg_info,
var_ind=met_ind,
modelInfo=model_params)
source('~/Documents/FLUXNET2016_processing/scripts/R/FluxtowerSpreadsheetToNc.R')
source('~/Documents/FLUXNET2016_processing/scripts/R/FluxtowerSpreadsheetToNc.R')
#Write met file
CreateMetNetcdfFile(metfilename=metfilename,
datain=DataFromText,
site_code=site_code,
siteInfo=site_info,
ind_start=gaps$tseries_start[k],
ind_end=gaps$tseries_end[k],
starttime=nc_starttime,
av_precip=av_precip[[k]],
total_missing=gaps$total_missing[[k]][met_ind],
total_gapfilled=gaps$total_gapfilled[[k]][met_ind],
qcInfo=qc_flags$qc_info,
arg_info=arg_info,
var_ind=met_ind,
modelInfo=model_params)
!is.na(arg_info$met_gapfill)
datain$gapfill_met
gap_methods <- datain$gapfill_met[which!is.na(datain$gapfill_met)]
gap_methods <- datain$gapfill_met[which(!is.na(datain$gapfill_met))]
gap_methods
names((var_defs))
x=1
names(var_defs[[1]])
names(var_defs[[1]]$name)
var_defs[[1]]$name
vnames(var_defs[[1]]$name)==names(gap_methods)ar_defs[[1]]$name
names(var_defs[[1]]$name)==names(gap_methods)
any(gap_names)==names(var_defs[[1]]$name)
gap_vars <- names(gap_methods)
any(gap_names)==names(var_defs[[1]]$name)
any(gap_vars)==names(var_defs[[1]]$name)
gap_vars
names(var_defs[[x]]$name)
any(gap_vars==names(var_defs[[x]]$name))
gap_methods[names(var_defs[[x]]$name)]
?ncatt_put
if(!is.na(arg_info$met_gapfill)){
gap_methods <- datain$gapfill_met[which(!is.na(datain$gapfill_met))]
gap_vars <- names(gap_methods)
lapply(1:length(var_defs), function(x) if(any(gap_vars==names(var_defs[[x]]$name))
ncatt_put(nc=ncid, varid=var_defs[[x]],
attname="Gapfilling_method",
attval=gap_methods[names(var_defs[[x]]$name)],
prec="text")))
}
!is.na(arg_info$met_gapfill)
gap_methods <- datain$gapfill_met[which(!is.na(datain$gapfill_met))]
gap_vars <- names(gap_methods)
lapply(1:length(var_defs), function(x) if(any(gap_vars==names(var_defs[[x]]$name))){
ncatt_put(nc=ncid, varid=var_defs[[x]],
attname="Gapfilling_method",
attval=gap_methods[names(var_defs[[x]]$name)],
prec="text")} )
nc_close(ncid)
source('~/Documents/FLUXNET2016_processing/scripts/R/FluxtowerSpreadsheetToNc.R')
#Write met file
CreateMetNetcdfFile(metfilename=metfilename,
datain=DataFromText,
site_code=site_code,
siteInfo=site_info,
ind_start=gaps$tseries_start[k],
ind_end=gaps$tseries_end[k],
starttime=nc_starttime,
av_precip=av_precip[[k]],
total_missing=gaps$total_missing[[k]][met_ind],
total_gapfilled=gaps$total_gapfilled[[k]][met_ind],
qcInfo=qc_flags$qc_info,
arg_info=arg_info,
var_ind=met_ind,
modelInfo=model_params)
#Write flux file
CreateFluxNetcdfFile(fluxfilename=fluxfilename, datain=DataFromText,
site_code=site_code,
siteInfo=site_info,
ind_start=gaps$tseries_start[k],
ind_end=gaps$tseries_end[k],
starttime=nc_starttime,
total_missing=gaps$total_missing[[k]][flux_ind[[k]]],
total_gapfilled=gaps$total_gapfilled[[k]][flux_ind[[k]]],
qcInfo=qc_flags$qc_info,
arg_info=arg_info,
var_ind=flux_ind[[k]],
modelInfo=model_params)
source('~/Documents/FLUXNET2016_processing/scripts/R/FluxtowerSpreadsheetToNc.R')
#Write flux file
CreateFluxNetcdfFile(fluxfilename=fluxfilename, datain=DataFromText,
site_code=site_code,
siteInfo=site_info,
ind_start=gaps$tseries_start[k],
ind_end=gaps$tseries_end[k],
starttime=nc_starttime,
total_missing=gaps$total_missing[[k]][flux_ind[[k]]],
total_gapfilled=gaps$total_gapfilled[[k]][flux_ind[[k]]],
qcInfo=qc_flags$qc_info,
arg_info=arg_info,
var_ind=flux_ind[[k]],
modelInfo=model_params)
gaps
plot(DataFromText$data[,"G_F_MDS"], type="l")
plot(DataFromText$data[,"G_F_MDS_QC"], type="l")
plot(DataFromText$data[gaps$tseries_start[k],"G_F_MDS_QC"], type="l")
plot(DataFromText$data[gaps$tseries_start[k]:gaps$tseries_end[k],"G_F_MDS_QC"], type="l")
length(DataFromText$data[gaps$tseries_start[k]:gaps$tseries_end[k],"G_F_MDS_QC"])
length(DataFromText$data[gaps$tseries_start[k]:gaps$tseries_end[k],"G_F_MDS_QC"] %in% 1:5)
length(which(DataFromText$data[gaps$tseries_start[k]:gaps$tseries_end[k],"G_F_MDS_QC"] %in% 1:5))
length(which(DataFromText$data[gaps$tseries_start[k]:gaps$tseries_end[k],"G_F_MDS_QC"] %in% -9999))
length(which(DataFromText$data[gaps$tseries_start[k]:gaps$tseries_end[k],"G_F_MDS_QC"] == -9999))
length(which(DataFromText$data[gaps$tseries_start[k]:gaps$tseries_end[k],"G_F_MDS_QC"] == c(1,2,3,4,5))
)
source('~/Documents/FLUXNET2016_processing/scripts/R/FluxtowerSpreadsheetToNc.R')
#Write met file
CreateMetNetcdfFile(metfilename=metfilename,
datain=DataFromText,
site_code=site_code,
siteInfo=site_info,
ind_start=gaps$tseries_start[k],
ind_end=gaps$tseries_end[k],
starttime=nc_starttime,
av_precip=av_precip[[k]],
total_missing=gaps$total_missing[[k]][met_ind],
total_gapfilled=gaps$total_gapfilled[[k]][met_ind],
qcInfo=qc_flags$qc_info,
arg_info=arg_info,
var_ind=met_ind,
modelInfo=model_params)
siteInfo$IGBP_vegetation_short
site_info$IGBP_vegetation_short
source('~/Documents/FLUXNET2016_processing/scripts/R/FluxtowerSpreadsheetToNc.R')
#Write met file
CreateMetNetcdfFile(metfilename=metfilename,
datain=DataFromText,
site_code=site_code,
siteInfo=site_info,
ind_start=gaps$tseries_start[k],
ind_end=gaps$tseries_end[k],
starttime=nc_starttime,
av_precip=av_precip[[k]],
total_missing=gaps$total_missing[[k]][met_ind],
total_gapfilled=gaps$total_gapfilled[[k]][met_ind],
qcInfo=qc_flags$qc_info,
arg_info=arg_info,
var_ind=met_ind,
modelInfo=model_params)
source('~/Documents/FLUXNET2016_processing/scripts/R/FluxtowerSpreadsheetToNc.R')
#Write met file
CreateMetNetcdfFile(metfilename=metfilename,
datain=DataFromText,
site_code=site_code,
siteInfo=site_info,
ind_start=gaps$tseries_start[k],
ind_end=gaps$tseries_end[k],
starttime=nc_starttime,
av_precip=av_precip[[k]],
total_missing=gaps$total_missing[[k]][met_ind],
total_gapfilled=gaps$total_gapfilled[[k]][met_ind],
qcInfo=qc_flags$qc_info,
arg_info=arg_info,
var_ind=met_ind,
modelInfo=model_params)
source('~/Documents/FLUXNET2016_processing/scripts/R/FluxtowerSpreadsheetToNc.R')
source('~/Documents/FLUXNET2016_processing/scripts/R/FluxtowerSpreadsheetToNc.R')
#Write met file
CreateMetNetcdfFile(metfilename=metfilename,
datain=DataFromText,
site_code=site_code,
siteInfo=site_info,
ind_start=gaps$tseries_start[k],
ind_end=gaps$tseries_end[k],
starttime=nc_starttime,
av_precip=av_precip[[k]],
total_missing=gaps$total_missing[[k]][met_ind],
total_gapfilled=gaps$total_gapfilled[[k]][met_ind],
qcInfo=qc_flags$qc_info,
arg_info=arg_info,
var_ind=met_ind,
modelInfo=model_params)
nc <- nc_open("~/Documents/FLUXNET2016_processing/Outputs/Nc_files/AU-How_2003-2005_FLUXNET2015_Met.nc")
veg_long <- ncvar_get(nc, "IGBP_veg_long")
veg_long
veg_long <- ncvar_get(nc, "IGBP_veg_short")
veg_long
source('~/Documents/FLUXNET2016_processing/scripts/R/FluxtowerSpreadsheetToNc.R')
devtools::document()
setwd("~/Documents/FLUXNET2016_processing/scripts/")
devtools::document()
devtools::install_github("aukkola/FluxnetLSM", ref="development")
